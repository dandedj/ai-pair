const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { ensureDirectoryExists } = require('./FileUtils');
const logger = require('./logger');

/**
 * Checks if a file is a test file based on its path.
 * @param {string} filePath - The file path to check.
 * @returns {boolean} - True if it's a test file; otherwise, false.
 */
function isTestFile(filePath) {
    return filePath.includes('/test/');
}

/**
 * Shows the diff between two files.
 * @param {string} originalPath - The path to the original file.
 * @param {string} newPath - The path to the new file.
 * @param {string} fileLabel - The label for the file being diffed.
 */
function showDiff(originalPath, newPath, fileLabel) {
    logger.info(`Proposed changes for ${fileLabel}: ${originalPath}`);
    try {
        const diffOutput = execSync(`diff --label "Original" ${originalPath} --label "Proposed" ${newPath}`).toString();
        logger.info(diffOutput);
    } catch (diffError) {
        if (diffError.stdout) {
            logger.info(diffError.stdout.toString());
        } else {
            logger.error(`Error diffing files: ${diffError.message}`);
        }
    }
    logger.info(`End of proposed changes for ${fileLabel}: ${originalPath}\n`);
}

/**
 * Parses and applies generated code from the AI client.
 * @param {string} generatedCode - The code generated by the AI client.
 * @param {string} tmpDir - The temporary directory for intermediate files.
 */
function parseAndApplyGeneratedCode(rootDir, tmpDir, generatedCode) {
    logger.info(`Parsing and applying generated code from ${rootDir}`);
    const codeBlocks = generatedCode.split(/File: (.+?)\n/).slice(1);

    logger.debug(`Found ${codeBlocks.length} code blocks in the generated code.`);

    if (codeBlocks.length === 0) {
        logger.error('No code blocks found in the generated code.');
        return;
    }

    for (let i = 0; i < codeBlocks.length; i += 2) {

        const filePath = codeBlocks[i].trim();
        const fileContent = codeBlocks[i + 1].trim();
        const fullPath = path.join(rootDir, filePath);
        const tempFilePath = path.join(tmpDir, filePath);

        // remove any markdown formatting from the file content
        const cleanedFileContent = fileContent.replace(/```[^\n]*```/g, '').trim();

        logger.debug(`Processing code block ${i + 1} of ${codeBlocks.length}: ${filePath}`);

        // ensure the temp file directory exists
        ensureDirectoryExists(path.dirname(tempFilePath));

        // check if the file content is empty
        if (cleanedFileContent.length === 0 || cleanedFileContent.trim() === '') {
            logger.error(`File content is empty for file: ${filePath}`);
            continue;
        }

        logger.debug(`Writing file content to temp file: ${tempFilePath}`);

        // write the file content to the temp file
        fs.writeFileSync(tempFilePath, cleanedFileContent);

        // Ensure the directory exists
        const dirName = path.dirname(fullPath);
        ensureDirectoryExists(dirName);

        const isTestFileFlag = isTestFile(filePath);

        if (isTestFileFlag) {
            logger.warn(`Attempted to modify a test file: ${filePath}. Changes will not be applied.`);
            showDiff(fullPath, tempFilePath, 'test file');
            continue; // Skip applying changes to test files
        }

        // Check if the file is new or a non-Java file
        const isNewFile = !fs.existsSync(fullPath);
        const isJavaFile = filePath.endsWith('.java');

        if (isNewFile) {
            logger.info(`New file will be added: ${filePath}`);
            logger.info(`Contents of the new file:\n${cleanedFileContent}`);
        } else if (!isJavaFile) {
            logger.warn(`A non-Java file will be changed: ${filePath}`);
            showDiff(fullPath, tempFilePath, 'non-Java file');
        } else {
            // Archive the original file
            const timestamp = new Date().toISOString().replace(/[-:.]/g, '');
            const archiveDir = path.join(tmpDir, 'archive/versions', path.dirname(filePath));
            ensureDirectoryExists(archiveDir);
            const archivePath = path.join(archiveDir, `${path.basename(filePath, '.java')}_${timestamp}.java`);
            fs.copyFileSync(fullPath, archivePath);

            // Show diff for existing files
            showDiff(fullPath, tempFilePath, 'file');
        }

        logger.debug(`Writing file content to original file: ${fullPath}`);

        // Write the file content
        fs.writeFileSync(fullPath, cleanedFileContent);

        // delete the temp file
        fs.unlinkSync(tempFilePath);
    }
}

module.exports = { parseAndApplyGeneratedCode }; 