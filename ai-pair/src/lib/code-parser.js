const fs = require('fs');
const path = require('path');
const { ensureDirectoryExists } = require('./file-utils');
const { logger } = require('./logger');

/**
 * Parses and applies generated code from the AI client.
 * @param {Object} config - The configuration object.
 * @param {string} generatedCode - The generated code from the AI.
 * @param {Object} runningState - The running state to update with code changes.
 * @returns {Object} - Details about the changes made.
 */
function parseAndApplyGeneratedCode(config, generatedCode, runningState) {
    logger.debug(`Parsing and applying generated code.`);

    const fileSections = splitIntoFileSections(generatedCode);
    let filesChanged = 0;
    let filesAdded = 0;
    let meaningfulChanges = 0;
    const changedFiles = [];
    const newFiles = [];

    for (const { filePath, code } of fileSections) {
        const fullPath = path.join(config.projectRoot, filePath);
        ensureDirectoryExists(path.dirname(fullPath));

        const isNewFile = !fs.existsSync(fullPath);
        const isTestFileFlag = isTestFile(filePath);
        const isSrcFile = filePath.endsWith(config.extension);

        if (isTestFileFlag) {
            logger.warn(`Attempted to modify a test file: ${filePath}. Changes will not be applied.`);
            continue;
        }

        if (isNewFile) {
            logger.debug(`New file will be added: ${filePath}`);
            filesAdded++;
            newFiles.push(filePath);
        } else if (!isSrcFile) {
            logger.warn(`A non-source file will be changed: ${filePath}`);
        } else {
            // Archive the original file
            archiveOriginalFile(fullPath, config.tmpDir, filePath);
            filesChanged++;
            changedFiles.push(filePath);
        }

        fs.writeFileSync(fullPath, code, 'utf-8');
        meaningfulChanges++;
        logger.info(`Applied changes to file: ${fullPath}`);
    }

    // Update runningState with code changes
    runningState.codeChanges = {
        lastChangeTime: new Date(),
        newFiles,
        modifiedFiles: changedFiles,
        deletedFiles: [], // Populate this if you handle deletions
        buildFiles: [], // Populate this if you handle build-related files
    };

    logger.info(`Summary: ${filesChanged} source files changed, ${filesAdded} files added, ${meaningfulChanges} meaningful changes.`);

    return {
        filesChanged,
        filesAdded,
        meaningfulChanges,
        changedFiles,
        newFiles,
    };
}

/**
 * Splits the generated code into sections, each corresponding to a file.
 * @param {string} generatedCode - The code generated by the AI.
 * @returns {Array} - An array of objects with file paths and code content.
 */
function splitIntoFileSections(generatedCode) {
    const fileSections = [];
    const fileSectionRegex = /(?:^|\n)File:\s*(.+?)\s*\n([\s\S]*?)(?=\nFile:\s*|$)/g;
    let match;

    while ((match = fileSectionRegex.exec(generatedCode)) !== null) {
        const filePath = match[1].trim();
        let codeContent = match[2].trim();

        // Check if code is within markdown code blocks
        const markdownCodeBlockRegex = /```[\s\S]*?```/g;
        const markdownMatch = markdownCodeBlockRegex.exec(codeContent);

        if (markdownMatch) {
            // Extract code from markdown code blocks
            codeContent = extractCodeFromMarkdown(codeContent);
        }

        fileSections.push({ filePath, code: codeContent });
        logger.debug(`Extracted code for file: ${filePath}`);
    }

    return fileSections;
}

/**
 * Extracts code from markdown code blocks.
 * @param {string} content - The content containing markdown code blocks.
 * @returns {string} - The concatenated code from all code blocks.
 */
function extractCodeFromMarkdown(content) {
    const codeBlocks = [];
    const codeBlockRegex = /```(?:\w+)?\n([\s\S]*?)```/g;
    let match;

    while ((match = codeBlockRegex.exec(content)) !== null) {
        const code = match[1].trim();
        codeBlocks.push(code);
    }

    return codeBlocks.join('\n');
}

/**
 * Archives the original file before changes.
 * @param {string} fullPath - The full path to the original file.
 * @param {string} tmpDir - The temporary directory for storing archives.
 * @param {string} filePath - The relative file path.
 */
function archiveOriginalFile(fullPath, tmpDir, filePath) {
    const timestamp = new Date().toISOString().replace(/[-:.]/g, '');
    const archiveDir = path.join(tmpDir, 'archive', 'versions', path.dirname(filePath));
    ensureDirectoryExists(archiveDir);
    const extension = path.extname(filePath);
    const baseName = path.basename(filePath, extension);
    const archivePath = path.join(archiveDir, `${baseName}_${timestamp}${extension}`);
    fs.copyFileSync(fullPath, archivePath);
    logger.debug(`Archived original file to: ${archivePath}`);
}

/**
 * Checks if a file is a test file based on its path.
 * @param {string} filePath - The file path to check.
 * @returns {boolean} - True if it's a test file; otherwise, false.
 */
function isTestFile(filePath) {
    return filePath.includes('/test/') || filePath.includes('\\test\\');
}

module.exports = { parseAndApplyGeneratedCode }; 