import fs from 'fs';
import path from 'path';
import { ensureDirectoryExists } from './file-utils';
import { logger } from './logger';
import Config from '../models/config';
import RunningState from '../models/running-state';
import CodeChangeSummary from '../models/code-change-summary';


interface FileSection {
    filePath: string;
    code: string;
}

/**
 * Parses and applies generated code from the AI client.
 * @param config - The configuration object.
 * @param generatedCode - The generated code from the AI.
 * @param runningState - The running state to update with code changes.
 * @returns Details about the changes made.
 */
function parseAndApplyGeneratedCode(config: Config, generatedCode: string, runningState: RunningState): CodeChangeSummary {
    logger.debug(`Parsing and applying generated code.`);

    const fileSections = splitIntoFileSections(generatedCode);
    let filesChanged = 0;
    let filesAdded = 0;
    let meaningfulChanges = 0;
    const changedFiles: string[] = [];
    const newFiles: string[] = [];

    for (const { filePath, code } of fileSections) {
        const fullPath = path.join(config.projectRoot, filePath);
        ensureDirectoryExists(path.dirname(fullPath));

        const isNewFile = !fs.existsSync(fullPath);
        const isTestFileFlag = isTestFile(filePath);
        const isSrcFile = filePath.endsWith(config.extension);

        if (isTestFileFlag) {
            logger.warn(`Attempted to modify a test file: ${filePath}. Changes will not be applied.`);
            continue;
        }

        if (isNewFile) {
            logger.debug(`New file will be added: ${filePath}`);
            filesAdded++;
            newFiles.push(filePath);
        } else if (!isSrcFile) {
            logger.warn(`A non-source file will be changed: ${filePath}`);
        } else {
            archiveOriginalFile(fullPath, config.tmpDir, filePath);
            filesChanged++;
            changedFiles.push(filePath);
        }

        fs.writeFileSync(fullPath, code, 'utf-8');
        meaningfulChanges++;
        logger.info(`Applied changes to file: ${fullPath}`);
    }

    const codeChangeSummary: CodeChangeSummary = {
        lastChangeTime: new Date(),
        newFiles,
        modifiedFiles: changedFiles,
        deletedFiles: [],
        buildFiles: [],
    };

    runningState.codeChanges = codeChangeSummary;
    logger.info(`Summary: ${filesChanged} source files changed, ${filesAdded} files added, ${meaningfulChanges} meaningful changes.`);

    return codeChangeSummary;
}

/**
 * Splits the generated code into sections, each corresponding to a file.
 * @param generatedCode - The code generated by the AI.
 * @returns An array of objects with file paths and code content.
 */
function splitIntoFileSections(generatedCode: string): FileSection[] {
    const fileSections: FileSection[] = [];
    const fileSectionRegex = /(?:^|\n)File:\s*(.+?)\s*\n([\s\S]*?)(?=\nFile:\s*|$)/g;
    let match;

    while ((match = fileSectionRegex.exec(generatedCode)) !== null) {
        const filePath = match[1].trim();
        let codeContent = match[2].trim();

        const markdownCodeBlockRegex = /```[\s\S]*?```/g;
        const markdownMatch = markdownCodeBlockRegex.exec(codeContent);

        if (markdownMatch) {
            codeContent = extractCodeFromMarkdown(codeContent);
        }

        fileSections.push({ filePath, code: codeContent });
        logger.debug(`Extracted code for file: ${filePath}`);
    }

    return fileSections;
}

/**
 * Extracts code from markdown code blocks.
 * @param content - The content containing markdown code blocks.
 * @returns The concatenated code from all code blocks.
 */
function extractCodeFromMarkdown(content: string): string {
    const codeBlocks: string[] = [];
    const codeBlockRegex = /```(?:\w+)?\n([\s\S]*?)```/g;
    let match;

    while ((match = codeBlockRegex.exec(content)) !== null) {
        const code = match[1].trim();
        codeBlocks.push(code);
    }

    return codeBlocks.join('\n');
}

/**
 * Archives the original file before changes.
 * @param fullPath - The full path to the original file.
 * @param tmpDir - The temporary directory for storing archives.
 * @param filePath - The relative file path.
 */
function archiveOriginalFile(fullPath: string, tmpDir: string, filePath: string): void {
    const timestamp = new Date().toISOString().replace(/[-:.]/g, '');
    const archiveDir = path.join(tmpDir, 'archive', 'versions', path.dirname(filePath));
    ensureDirectoryExists(archiveDir);
    const extension = path.extname(filePath);
    const baseName = path.basename(filePath, extension);
    const archivePath = path.join(archiveDir, `${baseName}_${timestamp}${extension}`);
    fs.copyFileSync(fullPath, archivePath);
    logger.debug(`Archived original file to: ${archivePath}`);
}

/**
 * Checks if a file is a test file based on its path.
 * @param filePath - The file path to check.
 * @returns True if it's a test file; otherwise, false.
 */
function isTestFile(filePath: string): boolean {
    return filePath.includes('/test/') || filePath.includes('\\test\\');
}

export { parseAndApplyGeneratedCode }; 